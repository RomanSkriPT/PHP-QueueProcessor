# QueueProcessor
QueueProcessor - is a simple PHP abstract class for building classes which could be _instantiated_ from several places and/or _almost simultaneously_ but should _process_ passed into them data _successively_ (one by one) _between all instances_.

###### USE CASE
<hr/>
The real use case of such class is a class for API requests to a _Service_ which provides several types of requests but allows only 1 request at a time from a given source. But your application uses this Service in various occasions, some of which for instance are generated by the users of your application. So you need to be sure that if there were generated a few simultaneous events which involve performing request to a _Service_, there will be no such simultaneous requests done.

###### HOW IT WORKS
><em>Instead, the Event #1 walks into communication room and locks the door. Does its job there. Unlocks the door and goes out. If there were some other events, that tried to access this room, while Event #1 were there, these events forms a queue, puts their request data in a common vault, gets their unique ID and starts knocking the door with a certain interval.</em>

><em>When Event #1 walks out and another event gets lucky to pass in, it walks in and locks the door. But before this Event X starts doing its own thing, it's obligated to check the queue list. If there are any other events, that are higher in the queue than Event X, then Event X gets their data from the vault, sends it, receives response and writes it down in the temporary journal signing with unique ID of each event-owner. Then Event X does its own job, unlocks the door and walks out.</em>

><em>The other events, while knocking the door of communication room also checks the temporary journal to find out if there is a response to their request data, in case some slyboots slipped before them into the room. If they finds what belongs to them, they takes it out and walks away.</em>

###### THE CODE
<hr/>
So `YourCustomClass` extended from `QueueProcessor` should implement three methods:
* `_processRequest($data)` - this is the main processing method of incoming data to `YourCustomClass` instance. This is where you should implement all the logic of processing of a single request `$data`. This method will be called by `_executeRequestInternal()` when the turn of a given instance of `YourCustomClass` will come.
* `_getQueueStaticDataDirRoot()` - should return a string with a full path to a directory where `QueueProcessor` will create a directory to store all queue data for `YourCustomClass`. Simply return a `__DIR__` to store that data within a parent directory of your class.
* `_addQueueLogMsg($msg)` - this is the logger. It's up to you turn it into a real logging method and write the logs, but `QueueProcessor` will use it to send a log messages about certain stages of execution process.
* By the way (this is obvious, but I'll mention it anyway), if you'll define a `__construct()` method in your child class, you must call a parent construct method first, since `QueueProcessor` need to do some initialization.

Thus here is a basic example of a child class:
```PHP
class YourCustomClass extends QueueProcessor {
    public function __construct() {
        parent::__construct();

        // Your initialization code here.
    }

    /**
     * Public execution callback.
     * @param mixed $data Request's data
     * @return array
     */
    public function execute($data) {
        // Here, in you public method for executing request,
        // you pass the incoming data to _executeRequestInternal() method,
        // which will handle the "queuing" and will call your implementation if _processRequest() method.
        return $this->_executeRequestInternal($data);
    }


    /**
     * Main request data processor.
     * @param mixed $data Request's data
     * @return mixed
     */
    protected function _processRequest($data) {
        $result = FALSE;
        
        // Your logic here.
        
        return $result;
    }


    /**
     * Return class' directory path.
     * @return string
     */
    protected function _getQueueStaticDataDirRoot() {
        return __DIR__;
    }


    /**
     * Save log.
     * @param string $msg
     */
    protected function _addQueueLogMsg($msg) {
        $this->addRealLog($msg);
    }
}
```

From the sample code above you might noticed, that all behind the scene work is done in `_executeRequestInternal()` method. And you're right. This method handles all the "queueing" work and calls the `_processRequest()` method for processing of a single request data. The result of processing of your particular request you'll get in an array format:
```
$result = array(
    'success'        => FALSE,
    'request_result' => NULL,
    'system'         => array(
        'msg'           => '',
        'queue_name'    => NULL
    ),
);
```